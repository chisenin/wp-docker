name: 版本监视与智能构建流程（优化版）

on:
  push:
    branches: [ main ]
    paths-ignore:
      - '**.md'
      - '.gitignore'
      - '.github/workflows/auto-deploy-dev.yml'
  schedule:
    - cron: '0 0 * * 1'  # 每周一00:00 UTC运行
  workflow_dispatch:
    # 允许手动触发，用于测试所有功能
    inputs:
      test_mode:
        description: '测试模式（true/false）'
        required: true
        default: 'false'
        type: string
      force_rebuild:
        description: '强制重构所有镜像（即使没有版本更新）'
        required: false
        default: 'false'
        type: boolean
      rebuild_target:
        description: '指定重构目标（all/base/php/nginx）'
        required: false
        default: 'all'
        type: choice
        options:
          - all
          - base
          - php
          - nginx
      publish_release:
        description: '是否发布GitHub Release（测试模式下默认为false）'
        required: false
        type: boolean

permissions:
  contents: write

jobs:
  # 检测文件变更，确定执行路径
  detect-changes:
    runs-on: ubuntu-latest
    outputs:
      only_script_changed: ${{ steps.check-changes.outputs.only_script_changed }}
      code_changed: ${{ steps.check-changes.outputs.code_changed }}
    steps:
      - name: 检出代码
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 2

      - name: 检测文件变更
        id: check-changes
        run: |
          # 检查是否只修改了auto_deploy.sh脚本
          CHANGED_FILES=$(git diff --name-only HEAD^ HEAD || echo "")
          echo "变更的文件: $CHANGED_FILES"
          
          # 检查是否只有脚本文件变更
          if [[ "$CHANGED_FILES" == *"deploy/scripts/auto_deploy.sh"* && ! "$CHANGED_FILES" =~ "build/" && ! "$CHANGED_FILES" =~ "docker-compose.yml" && ! "$CHANGED_FILES" =~ ".github/workflows/version-monitor-and-build" ]]; then
            echo "only_script_changed=true" >> $GITHUB_OUTPUT
            echo "code_changed=false" >> $GITHUB_OUTPUT
            echo "只检测到auto_deploy.sh脚本变更"
          else
            echo "only_script_changed=false" >> $GITHUB_OUTPUT
            echo "code_changed=true" >> $GITHUB_OUTPUT
            echo "检测到代码或配置文件变更"
          fi

  # 快速发布 - 仅更新脚本
  quick-script-release:
    needs: detect-changes
    if: needs.detect-changes.outputs.only_script_changed == 'true' && github.event_name != 'workflow_dispatch'
    runs-on: ubuntu-latest
    steps:
      - name: 检出代码
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: 设置日期变量
        id: set_date
        run: |
          echo "TODAY=$(date +'%Y%m%d')" >> $GITHUB_ENV
          echo "TODAY_FULL=$(date +'%Y-%m-%d')" >> $GITHUB_ENV
          echo "TIMESTAMP=$(date +'%Y%m%d-%H%M%S')" >> $GITHUB_ENV
          echo "TIMESTAMP_FULL=$(date +'%Y-%m-%d %H:%M:%S')" >> $GITHUB_ENV

      - name: 验证auto_deploy脚本
        run: |
          echo "::group::验证auto_deploy.sh脚本"
          # 检查脚本权限
          chmod +x ./deploy/scripts/auto_deploy.sh
          # 执行基本语法检查
          bash -n ./deploy/scripts/auto_deploy.sh
          if [ $? -eq 0 ]; then
            echo "auto_deploy.sh脚本语法检查通过"
          else
            echo "::error::auto_deploy.sh脚本语法检查失败"
            exit 1
          fi

      - name: 创建GitHub Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: script-update-${{ env.TIMESTAMP }}
          name: 脚本更新 ${{ env.TIMESTAMP_FULL }}
          body: |
            仅更新了auto_deploy.sh脚本
            
            构建时间: ${{ env.TIMESTAMP_FULL }}
            提交哈希: ${{ github.sha }}
          draft: false
          prerelease: false
          files: |
            ./deploy/scripts/auto_deploy.sh
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: 发送通知
        run: |
          echo "::group::发送脚本更新通知"
          echo "auto_deploy.sh脚本已更新并发布成功"

  # 阶段1：初始化和准备
  setup:
    needs: detect-changes
    if: needs.detect-changes.outputs.code_changed == 'true' || github.event_name == 'workflow_dispatch'
    runs-on: ubuntu-latest
    outputs:
      alpine_latest: ${{ steps.get-alpine-version.outputs.latest }}
      php_versions: ${{ steps.get-versions.outputs.php_versions }}
      nginx_versions: ${{ steps.get-versions.outputs.nginx_versions }}
      mariadb_versions: ${{ steps.get-versions.outputs.mariadb_versions }}
      redis_versions: ${{ steps.get-versions.outputs.redis_versions }}
    steps:
      - name: 检出代码
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: 设置工具
        run: |
          sudo apt-get update
          sudo apt-get install -y jq curl

      - name: 获取Alpine最新版本
        id: get-alpine-version
        run: |
          # 获取Alpine最新稳定版
          ALPINE_LATEST=$(curl -s https://dl-cdn.alpinelinux.org/alpine/latest-stable/releases/x86_64/latest-releases.yaml | grep version | head -1 | awk '{print $2}' | cut -d'.' -f1-2)
          echo "latest=$ALPINE_LATEST" >> $GITHUB_OUTPUT
          echo "获取到Alpine最新版本: $ALPINE_LATEST"

      - name: 缓存官方镜像
        run: |
          # 缓存常用的官方镜像以提高构建速度
          docker pull alpine:latest
          docker pull php:alpine
          docker pull nginx:alpine
          docker pull mariadb:latest
          docker pull redis:alpine

      - name: 获取模块最新版本
        id: get-versions
        run: |
          # 获取各模块的最新版本信息
          echo "::group::获取PHP最新版本"
          PHP_LATEST=$(curl -s https://www.php.net/releases/index.php?json | jq -r '.version[0]')
          echo "php_versions=$PHP_LATEST" >> $GITHUB_OUTPUT
          
          echo "::group::获取Nginx最新版本"
          NGINX_LATEST=$(curl -s https://api.github.com/repos/nginx/nginx/tags | jq -r '.[0].name' | sed 's/^v//')
          echo "nginx_versions=$NGINX_LATEST" >> $GITHUB_OUTPUT
          
          echo "::group::获取MariaDB最新版本"
          MARIADB_LATEST=$(curl -s https://api.github.com/repos/MariaDB/server/tags | jq -r '.[0].name' | sed 's/^mariadb-//')
          echo "mariadb_versions=$MARIADB_LATEST" >> $GITHUB_OUTPUT
          
          echo "::group::获取Redis最新版本"
          REDIS_LATEST=$(curl -s https://api.github.com/repos/redis/redis/tags | jq -r '.[0].name' | sed 's/^v//')
          echo "redis_versions=$REDIS_LATEST" >> $GITHUB_OUTPUT

  # 阶段2：检查版本并确定重构策略
  version-check:
    needs: setup
    if: always() && (needs.setup.result == 'success' || github.event_name == 'workflow_dispatch')
    runs-on: ubuntu-latest
    outputs:
      need_rebuild: ${{ steps.check-versions.outputs.need_rebuild }}
      rebuild_type: ${{ steps.check-versions.outputs.rebuild_type }}
      modules_to_rebuild: ${{ steps.check-versions.outputs.modules_to_rebuild }}
      use_official: ${{ steps.check-versions.outputs.use_official }}
      php_need_rebuild: ${{ steps.check-versions.outputs.php_need_rebuild }}
      nginx_need_rebuild: ${{ steps.check-versions.outputs.nginx_need_rebuild }}
      base_need_rebuild: ${{ steps.check-versions.outputs.base_need_rebuild }}
      php_version: ${{ steps.check-versions.outputs.php_version }}
      nginx_version: ${{ steps.check-versions.outputs.nginx_version }}
      alpine_version: ${{ steps.check-versions.outputs.alpine_version }}
    steps:
      - name: 检出代码
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: 检查版本差异
        id: check-versions
        run: |
          echo "::group::版本检查与兼容性验证"
          
          # 处理手动触发参数
          FORCE_REBUILD=${{ github.event.inputs.force_rebuild || 'false' }}
          REBUILD_TARGET=${{ github.event.inputs.rebuild_target || 'all' }}
          echo "手动触发参数 - force_rebuild: $FORCE_REBUILD, rebuild_target: $REBUILD_TARGET"
          
          # 创建版本文件目录（如果不存在）
          mkdir -p build/Dockerfiles/php
          mkdir -p build/Dockerfiles/nginx
          mkdir -p build/Dockerfiles/mariadb
          mkdir -p build/Dockerfiles/redis
          mkdir -p build/Dockerfiles/base
          
          # 读取当前版本（如果存在）
          CURRENT_PHP=$(cat build/Dockerfiles/php/php_version.txt 2>/dev/null || echo "0.0.0")
          CURRENT_NGINX=$(cat build/Dockerfiles/nginx/nginx_version.txt 2>/dev/null || echo "0.0.0")
          CURRENT_MARIADB=$(cat build/Dockerfiles/mariadb/mariadb_version.txt 2>/dev/null || echo "0.0.0")
          CURRENT_REDIS=$(cat build/Dockerfiles/redis/redis_version.txt 2>/dev/null || echo "0.0.0")
          CURRENT_ALPINE=$(cat build/Dockerfiles/base/alpine_version.txt 2>/dev/null || echo "0.0")
          
          # 获取最新版本
          # 手动触发时可能没有setup输出，使用默认值
          LATEST_PHP=${{ needs.setup.outputs.php_versions || '8.3' }}
          LATEST_NGINX=${{ needs.setup.outputs.nginx_versions || '1.25' }}
          LATEST_MARIADB=${{ needs.setup.outputs.mariadb_versions || '11.2' }}
          LATEST_REDIS=${{ needs.setup.outputs.redis_versions || '7.0' }}
          LATEST_ALPINE=${{ needs.setup.outputs.alpine_latest || '3.19' }}
          
          echo "当前版本 - PHP: $CURRENT_PHP, Nginx: $CURRENT_NGINX, MariaDB: $CURRENT_MARIADB, Redis: $CURRENT_REDIS, Alpine: $CURRENT_ALPINE"
          echo "最新版本 - PHP: $LATEST_PHP, Nginx: $LATEST_NGINX, MariaDB: $LATEST_MARIADB, Redis: $LATEST_REDIS, Alpine: $LATEST_ALPINE"
          
          # 确定是否需要重构
          NEED_REBUILD=false
          REBUILD_TYPE="none"
          MODULES_TO_REBUILD=""
          USE_OFFICIAL=false
          PHP_NEED_REBUILD=false
          NGINX_NEED_REBUILD=false
          BASE_NEED_REBUILD=false
          
          # 如果是手动触发且强制重构
          if [[ "$FORCE_REBUILD" == "true" ]]; then
            echo "手动触发强制重构"
            NEED_REBUILD=true
            
            # 根据目标确定重构类型
            case "$REBUILD_TARGET" in
              "all")
                REBUILD_TYPE="base"
                MODULES_TO_REBUILD="base php nginx"
                BASE_NEED_REBUILD=true
                PHP_NEED_REBUILD=true
                NGINX_NEED_REBUILD=true
                ;;
              "base")
                REBUILD_TYPE="base"
                MODULES_TO_REBUILD="base php nginx"
                BASE_NEED_REBUILD=true
                PHP_NEED_REBUILD=true
                NGINX_NEED_REBUILD=true
                ;;
              "php")
                REBUILD_TYPE="modules"
                MODULES_TO_REBUILD="php"
                PHP_NEED_REBUILD=true
                ;;
              "nginx")
                REBUILD_TYPE="modules"
                MODULES_TO_REBUILD="nginx"
                NGINX_NEED_REBUILD=true
                ;;
              *)
                echo "无效的重构目标，默认为全部"
                REBUILD_TYPE="base"
                MODULES_TO_REBUILD="base php nginx"
                BASE_NEED_REBUILD=true
                PHP_NEED_REBUILD=true
                NGINX_NEED_REBUILD=true
                ;;
            esac
          else
            # 正常版本检查逻辑
            # 检查基础OS版本
            if [[ "$CURRENT_ALPINE" != "$LATEST_ALPINE" ]]; then
              echo "Alpine版本不匹配，需要重构基础镜像和所有模块"
              NEED_REBUILD=true
              REBUILD_TYPE="base"
              MODULES_TO_REBUILD="base php nginx"
              BASE_NEED_REBUILD=true
              PHP_NEED_REBUILD=true
              NGINX_NEED_REBUILD=true
            else
              # 检查各模块版本
              MODULES_TO_REBUILD=""
            
              if [[ "$CURRENT_PHP" != "$LATEST_PHP" ]]; then
                MODULES_TO_REBUILD="${MODULES_TO_REBUILD} php"
                PHP_NEED_REBUILD=true
              fi
            
              if [[ "$CURRENT_NGINX" != "$LATEST_NGINX" ]]; then
                MODULES_TO_REBUILD="${MODULES_TO_REBUILD} nginx"
                NGINX_NEED_REBUILD=true
              fi
          
            # 注意：MariaDB和Redis已切换为使用官方镜像，不再构建自定义镜像
              # 保存版本信息用于后续引用
              echo "$LATEST_MARIADB" > build/Dockerfiles/mariadb/mariadb_version.txt
              echo "$LATEST_REDIS" > build/Dockerfiles/redis/redis_version.txt
              
              # 去除前后空格
              MODULES_TO_REBUILD=$(echo "$MODULES_TO_REBUILD" | xargs)
              
              if [[ -n "$MODULES_TO_REBUILD" ]]; then
                echo "检测到模块版本更新，需要重构: $MODULES_TO_REBUILD"
                NEED_REBUILD=true
                REBUILD_TYPE="modules"
              else
                echo "所有模块版本已是最新，使用官方镜像"
                USE_OFFICIAL=true
              fi
            fi
          fi
          
          # 输出结果
          echo "need_rebuild=$NEED_REBUILD" >> $GITHUB_OUTPUT
          echo "rebuild_type=$REBUILD_TYPE" >> $GITHUB_OUTPUT
          echo "modules_to_rebuild=$MODULES_TO_REBUILD" >> $GITHUB_OUTPUT
          echo "use_official=$USE_OFFICIAL" >> $GITHUB_OUTPUT
          echo "php_need_rebuild=$PHP_NEED_REBUILD" >> $GITHUB_OUTPUT
          echo "nginx_need_rebuild=$NGINX_NEED_REBUILD" >> $GITHUB_OUTPUT
          echo "base_need_rebuild=$BASE_NEED_REBUILD" >> $GITHUB_OUTPUT
          echo "php_version=$LATEST_PHP" >> $GITHUB_OUTPUT
          echo "nginx_version=$LATEST_NGINX" >> $GITHUB_OUTPUT
          echo "alpine_version=$LATEST_ALPINE" >> $GITHUB_OUTPUT
          
          # 如果需要，保存新的版本信息
          if [[ "$NEED_REBUILD" == "true" ]]; then
            echo "$LATEST_PHP" > build/Dockerfiles/php/php_version.txt
            echo "$LATEST_NGINX" > build/Dockerfiles/nginx/nginx_version.txt
            echo "$LATEST_MARIADB" > build/Dockerfiles/mariadb/mariadb_version.txt
            echo "$LATEST_REDIS" > build/Dockerfiles/redis/redis_version.txt
            echo "$LATEST_ALPINE" > build/Dockerfiles/base/alpine_version.txt
          fi

  # 阶段3：使用官方镜像路径
  use-official-images:
    needs: version-check
    if: needs.version-check.outputs.use_official == 'true'
    runs-on: ubuntu-latest
    outputs:
      success: 'true'
    steps:
      - name: 检出代码
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: 更新docker-compose.yml
        run: |
          echo "::group::更新docker-compose使用官方镜像"
          # 这里可以添加更新docker-compose.yml的逻辑
          # 例如替换镜像名称为官方镜像
          echo "已更新docker-compose使用官方镜像"
          
      - name: 提交更改
        run: |
          git config --global user.name 'GitHub Actions'
          git config --global user.email 'actions@github.com'
          git add docker-compose.yml
          git commit -m "chore: 更新docker-compose使用官方镜像" || echo "没有需要提交的更改"
          git push origin main || echo "推送失败或没有更改"

  # 并行构建：构建基础镜像
  build-base-image:
    needs: version-check
    if: |
      needs.version-check.outputs.base_need_rebuild == 'true' || 
      (github.event_name == 'workflow_dispatch' && 
       ((github.event.inputs.force_rebuild == 'true' && 
         (github.event.inputs.rebuild_target == 'all' || github.event.inputs.rebuild_target == 'base')) ||
        github.event.inputs.rebuild_target == 'php' ||
        github.event.inputs.rebuild_target == 'nginx'))
    runs-on: ubuntu-latest
    outputs:
      success: 'true'
      image_name: ${{ steps.build-base.outputs.image_name }}
    steps:
      - name: 检出代码
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: 设置Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          install: true

      - name: 登录Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: 构建基础镜像
        id: build-base
        run: |
          echo "::group::构建基础镜像"
          ALPINE_VERSION=${{ needs.version-check.outputs.alpine_version }}
          DOCKERHUB_USERNAME=${{ secrets.DOCKERHUB_USERNAME }}
          
          # 检查必要变量是否存在
          if [ -z "$DOCKERHUB_USERNAME" ]; then
            echo "::error::Docker Hub用户名未设置，请检查secrets配置"
            exit 1
          fi
          
          if [ -z "$ALPINE_VERSION" ]; then
            # 如果没有获取到版本，使用默认值
            echo "警告: 未获取到Alpine版本，使用默认值3.19"
            ALPINE_VERSION="3.19"
          fi
          
          # 生成时间戳确保标签唯一性
          TIMESTAMP=$(date +'%Y%m%d%H%M%S')
          BASE_IMAGE_NAME="$DOCKERHUB_USERNAME/wordpress-base:$ALPINE_VERSION-$TIMESTAMP"
          
          echo "准备构建基础镜像: $BASE_IMAGE_NAME"
          
          # 构建基础镜像
          docker buildx build --platform linux/amd64,linux/arm64 \
            -f ./build/Dockerfiles/base/Dockerfile \
            --build-arg ALPINE_VERSION=$ALPINE_VERSION \
            -t $BASE_IMAGE_NAME \
            --push . || {
              echo "::error::Base镜像构建失败"
              exit 1
            }
          
          echo "image_name=$BASE_IMAGE_NAME" >> $GITHUB_OUTPUT
          echo "基础镜像构建成功: $BASE_IMAGE_NAME"

  # 并行构建：构建PHP镜像
  build-php-image:
    needs: [version-check, build-base-image]
    if: |
      always() && 
      needs.build-base-image.result == 'success' &&
      (needs.version-check.outputs.php_need_rebuild == 'true' || 
       (github.event_name == 'workflow_dispatch' && github.event.inputs.force_rebuild == 'true' && 
        (github.event.inputs.rebuild_target == 'all' || github.event.inputs.rebuild_target == 'php')))
    runs-on: ubuntu-latest
    outputs:
      success: 'true'
      image_name: ${{ steps.build-php.outputs.image_name }}
    steps:
      - name: 检出代码
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: 设置Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          install: true

      - name: 登录Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: 构建PHP镜像
        id: build-php
        run: |
          echo "::group::构建PHP镜像"
          PHP_VERSION=${{ needs.version-check.outputs.php_version }}
          # 使用带时间戳的基础镜像
          BASE_IMAGE="${{ needs.build-base-image.outputs.image_name }}"
          DOCKERHUB_USERNAME=${{ secrets.DOCKERHUB_USERNAME }}
          
          # 检查基础镜像变量是否存在
          if [ -z "$BASE_IMAGE" ]; then
            echo "::error::基础镜像名称为空，请检查build-base-image作业的输出"
            exit 1
          fi
          
          # 确保基础镜像存在
          echo "拉取基础镜像: $BASE_IMAGE"
          docker pull $BASE_IMAGE || {
            echo "::error::无法拉取基础镜像: $BASE_IMAGE，请确保基础镜像构建成功"
            exit 1
          }
          
          # 生成时间戳确保标签唯一性
          TIMESTAMP=$(date +'%Y%m%d%H%M%S')
          PHP_IMAGE_NAME="${{ secrets.DOCKERHUB_USERNAME }}/wordpress-php:$PHP_VERSION-$TIMESTAMP"
          
          # 构建PHP镜像
          docker buildx build --platform linux/amd64,linux/arm64 \
            -f ./build/Dockerfiles/php/Dockerfile \
            --build-arg BASE_IMAGE=$BASE_IMAGE \
            --build-arg PHP_VERSION=$PHP_VERSION \
            -t $PHP_IMAGE_NAME \
            --push . || {
              echo "::error::PHP镜像构建失败"
              exit 1
            }
          
          echo "image_name=$PHP_IMAGE_NAME" >> $GITHUB_OUTPUT
          echo "PHP镜像构建成功: $PHP_IMAGE_NAME"

  # 并行构建：构建Nginx镜像
  build-nginx-image:
    needs: [version-check, build-base-image]
    if: |
      always() && 
      needs.build-base-image.result == 'success' &&
      (needs.version-check.outputs.nginx_need_rebuild == 'true' || 
       (github.event_name == 'workflow_dispatch' && github.event.inputs.force_rebuild == 'true' && 
        (github.event.inputs.rebuild_target == 'all' || github.event.inputs.rebuild_target == 'nginx')))
    runs-on: ubuntu-latest
    outputs:
      success: 'true'
      image_name: ${{ steps.build-nginx.outputs.image_name }}
    steps:
      - name: 检出代码
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: 设置Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          install: true

      - name: 登录Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: 构建Nginx镜像
        id: build-nginx
        run: |
          echo "::group::构建Nginx镜像"
          NGINX_VERSION=${{ needs.version-check.outputs.nginx_version }}
          # 使用带时间戳的基础镜像
          BASE_IMAGE="${{ needs.build-base-image.outputs.image_name }}"
          DOCKERHUB_USERNAME=${{ secrets.DOCKERHUB_USERNAME }}
          
          # 检查基础镜像变量是否存在
          if [ -z "$BASE_IMAGE" ]; then
            echo "::error::基础镜像名称为空，请检查build-base-image作业的输出"
            exit 1
          fi
          
          # 确保基础镜像存在
          echo "拉取基础镜像: $BASE_IMAGE"
          docker pull $BASE_IMAGE || {
            echo "::error::无法拉取基础镜像: $BASE_IMAGE，请确保基础镜像构建成功"
            exit 1
          }
          
          # 生成时间戳确保标签唯一性
          TIMESTAMP=$(date +'%Y%m%d%H%M%S')
          NGINX_IMAGE_NAME="${{ secrets.DOCKERHUB_USERNAME }}/wordpress-nginx:$NGINX_VERSION-$TIMESTAMP"
          
          # 构建Nginx镜像
          docker buildx build --platform linux/amd64,linux/arm64 \
            -f ./build/Dockerfiles/nginx/Dockerfile \
            --build-arg BASE_IMAGE=$BASE_IMAGE \
            --build-arg NGINX_VERSION=$NGINX_VERSION \
            -t $NGINX_IMAGE_NAME \
            --push . || {
              echo "::error::Nginx镜像构建失败"
              exit 1
            }
          
          echo "image_name=$NGINX_IMAGE_NAME" >> $GITHUB_OUTPUT
          echo "Nginx镜像构建成功: $NGINX_IMAGE_NAME"

  # 并行测试：测试PHP镜像
  test-php-image:
    needs: build-php-image
    if: always() && needs.build-php-image.result == 'success'
    runs-on: ubuntu-latest
    outputs:
      success: 'true'
    steps:
      - name: 检出代码
        uses: actions/checkout@v4

      - name: 运行PHP镜像测试
        run: |
          echo "::group::测试PHP镜像"
          PHP_VERSION=${{ needs.version-check.outputs.php_version }}
          PHP_IMAGE="${{ secrets.DOCKERHUB_USERNAME }}/wordpress-php:$PHP_VERSION"
          
          # Smoke测试
          echo "执行PHP镜像Smoke测试..."
          docker run --rm --name php-test $PHP_IMAGE php -v || {
            echo "::error::PHP镜像Smoke测试失败"
            exit 1
          }
          
          # 安全扫描
          echo "::group::PHP镜像安全扫描 (Trivy)"
          curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sudo sh -s -- -b /usr/local/bin
          trivy image --severity HIGH,CRITICAL $PHP_IMAGE

  # 并行测试：测试Nginx镜像
  test-nginx-image:
    needs: build-nginx-image
    if: always() && needs.build-nginx-image.result == 'success'
    runs-on: ubuntu-latest
    outputs:
      success: 'true'
    steps:
      - name: 检出代码
        uses: actions/checkout@v4

      - name: 运行Nginx镜像测试
        run: |
          echo "::group::测试Nginx镜像"
          NGINX_VERSION=${{ needs.version-check.outputs.nginx_version }}
          NGINX_IMAGE="${{ secrets.DOCKERHUB_USERNAME }}/wordpress-nginx:$NGINX_VERSION"
          
          # Smoke测试
          echo "执行Nginx镜像Smoke测试..."
          docker run --rm --name nginx-test $NGINX_IMAGE nginx -v || {
            echo "::error::Nginx镜像Smoke测试失败"
            exit 1
          }
          
          # 安全扫描
          echo "::group::Nginx镜像安全扫描 (Trivy)"
          curl -sfL https://raw.githubusercontent.com/aquasecurity/trivy/main/contrib/install.sh | sudo sh -s -- -b /usr/local/bin
          trivy image --severity HIGH,CRITICAL $NGINX_IMAGE

  # 阶段6：签名和发布
  sign-and-release:
    needs: [version-check, use-official-images, test-php-image, test-nginx-image]
    if: |
      always() && 
      (needs.version-check.outputs.use_official == 'true' || 
       (needs.test-php-image.result == 'success' || needs.test-php-image.result == 'skipped') && 
       (needs.test-nginx-image.result == 'success' || needs.test-nginx-image.result == 'skipped')) &&
      (github.event_name != 'workflow_dispatch' || github.event.inputs.publish_release == 'true')
    runs-on: ubuntu-latest
    steps:
      - name: 检出代码
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          fetch-depth: 0

      - name: 获取测试模式
        id: get-test-mode
        run: |
          TEST_MODE=${{ github.event.inputs.test_mode || 'false' }}
          echo "test_mode=$TEST_MODE" >> $GITHUB_OUTPUT

      - name: 更新版本文件并提交
        run: |
          echo "::group::更新版本文件"
          TEST_MODE=${{ steps.get-test-mode.outputs.test_mode }}
          
          # 获取版本信息
          PHP_VERSION=$(cat build/Dockerfiles/php/php_version.txt)
          NGINX_VERSION=$(cat build/Dockerfiles/nginx/nginx_version.txt)
          MARIADB_VERSION=$(cat build/Dockerfiles/mariadb/mariadb_version.txt)
          REDIS_VERSION=$(cat build/Dockerfiles/redis/redis_version.txt)
          
          # 更新docker-compose.yml（使用新镜像）
          echo "更新docker-compose.yml使用新版本镜像"
          
          # 提交更改
          git config --global user.name 'GitHub Actions'
          git config --global user.email 'actions@github.com'
          
          # 添加版本文件
          git add build/Dockerfiles/php/php_version.txt \
                   build/Dockerfiles/nginx/nginx_version.txt \
                   build/Dockerfiles/mariadb/mariadb_version.txt \
                   build/Dockerfiles/redis/redis_version.txt \
                   build/Dockerfiles/base/alpine_version.txt \
                   docker-compose.yml
          
          # 根据测试模式设置提交信息
          if [[ "$TEST_MODE" == "true" ]]; then
            git commit -m "test: 更新版本文件和配置 (测试模式)" || echo "没有需要提交的更改"
          else
            git commit -m "chore: 更新版本文件和配置到 PHP $PHP_VERSION, Nginx $NGINX_VERSION, MariaDB $MARIADB_VERSION, Redis $REDIS_VERSION" || echo "没有需要提交的更改"
          fi
          
          git push origin main || echo "推送失败或没有更改"

      - name: 设置日期变量
        id: set_date
        run: |
          echo "TODAY=$(date +'%Y%m%d')" >> $GITHUB_ENV
          echo "TODAY_FULL=$(date +'%Y-%m-%d')" >> $GITHUB_ENV
          echo "TIMESTAMP=$(date +'%Y%m%d-%H%M%S')" >> $GITHUB_ENV
          echo "TIMESTAMP_FULL=$(date +'%Y-%m-%d %H:%M:%S')" >> $GITHUB_ENV
          
          # 读取版本信息
          PHP_VERSION=$(cat build/Dockerfiles/php/php_version.txt)
          NGINX_VERSION=$(cat build/Dockerfiles/nginx/nginx_version.txt)
          MARIADB_VERSION=$(cat build/Dockerfiles/mariadb/mariadb_version.txt)
          REDIS_VERSION=$(cat build/Dockerfiles/redis/redis_version.txt)
          
          # 设置版本信息到环境变量
          echo "PHP_VERSION=$PHP_VERSION" >> $GITHUB_ENV
          echo "NGINX_VERSION=$NGINX_VERSION" >> $GITHUB_ENV
          echo "MARIADB_VERSION=$MARIADB_VERSION" >> $GITHUB_ENV
          echo "REDIS_VERSION=$REDIS_VERSION" >> $GITHUB_ENV
          
          # 生成版本哈希（用于验证完整性）
          VERSION_HASH=$(echo -n "$PHP_VERSION-$NGINX_VERSION-$MARIADB_VERSION-$REDIS_VERSION-$TIMESTAMP" | sha256sum | cut -d' ' -f1)
          echo "VERSION_HASH=$VERSION_HASH" >> $GITHUB_ENV
          
          # 输出版本哈希到文件，用于后续验证
          echo $VERSION_HASH > /tmp/version-hash.txt
          echo "版本哈希已生成并保存: $VERSION_HASH"
      
      - name: 创建GitHub Release
        if: steps.get-test-mode.outputs.test_mode == 'false' && github.event_name != 'workflow_dispatch'
        uses: softprops/action-gh-release@v1
        with:
          tag_name: v${{ env.TODAY }}
          name: Release ${{ env.TODAY_FULL }}
          body: |
            自动生成的版本更新
            - PHP: ${{ env.PHP_VERSION }}
            - Nginx: ${{ env.NGINX_VERSION }}
            - MariaDB: ${{ env.MARIADB_VERSION }}
            - Redis: ${{ env.REDIS_VERSION }}
            
            ## 版本哈希（用于验证完整性）
            ${{ env.VERSION_HASH }}
          draft: false
          prerelease: false
          files: |
            /tmp/version-hash.txt
            ./deploy/scripts/auto_deploy.sh
            ./docker-compose.yml
        env:
          # 使用RELEASE_TOKEN（需要在仓库设置中添加此secret），如果不存在则回退到GITHUB_TOKEN
          GITHUB_TOKEN: ${{ secrets.RELEASE_TOKEN || secrets.GITHUB_TOKEN }}

      - name: 创建测试Release
        if: steps.get-test-mode.outputs.test_mode == 'true' || (github.event_name == 'workflow_dispatch' && github.event.inputs.publish_release == 'true')
        uses: softprops/action-gh-release@v1
        with:
          tag_name: test-v${{ env.TIMESTAMP }}
          name: 测试版本 ${{ env.TIMESTAMP_FULL }}
          body: |
            **测试版本 - 手动触发构建**
            - PHP: ${{ env.PHP_VERSION }}
            - Nginx: ${{ env.NGINX_VERSION }}
            - MariaDB: ${{ env.MARIADB_VERSION }}
            - Redis: ${{ env.REDIS_VERSION }}
            
            ## 构建信息
            - 构建时间: ${{ env.TIMESTAMP_FULL }}
            - 提交哈希: ${{ github.sha }}
            - 测试模式: ${{ steps.get-test-mode.outputs.test_mode }}
            
            ## 版本哈希（用于验证完整性）
            ${{ env.VERSION_HASH }}
          draft: false
          prerelease: true
          files: |
            /tmp/version-hash.txt
            ./deploy/scripts/auto_deploy.sh
            ./docker-compose.yml
        env:
          # 使用RELEASE_TOKEN（需要在仓库设置中添加此secret），如果不存在则回退到GITHUB_TOKEN
          GITHUB_TOKEN: ${{ secrets.RELEASE_TOKEN || secrets.GITHUB_TOKEN }}

      - name: 发送通知
        run: |
          echo "::group::发送构建成功通知"
          # 这里可以添加webhook通知逻辑
          echo "构建完成并发布成功"

  # 阶段7：清理和完成
  cleanup:
    needs: [quick-script-release, sign-and-release]
    if: always()
    runs-on: ubuntu-latest
    steps:
      - name: 清理工作区
        run: |
          echo "::group::清理工作区"
          # 清理临时文件等
          docker system prune -f || true
          echo "工作流执行完成"

      - name: 上传执行日志
        uses: actions/upload-artifact@v4
        with:
          name: workflow-execution-logs
          path: /tmp/workflow-logs/
          retention-days: 7