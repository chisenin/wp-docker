name: Build and Push Docker Images

on:
  push:
    branches: [ main, test-nginx-only, verify-only ]
  pull_request:
    branches: [ main, test-nginx-only, verify-only ]

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    # 为verify-only分支添加条件，根据分支决定是否跳过构建和推送步骤
    env:
      SKIP_BUILD_PUSH: ${{ github.ref == 'refs/heads/verify-only' }}

    steps:
      - name: 检出代码
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: 设置 Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          install: true

      - name: 登录 Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: 提取 PHP 和 Nginx 版本
        id: extract
        run: |
          echo "::group::提取版本"
          PHP_VERSION=$(cat Dockerfiles/php/php_version.txt 2>/dev/null || echo '8.3.26')
          NGINX_VERSION=$(cat Dockerfiles/nginx/nginx_version.txt 2>/dev/null || echo '1.27.2')

          [ ! -f Dockerfiles/php/php_version.txt ] && echo "::warning::PHP 版本文件缺失，默认使用 $PHP_VERSION"
          [ ! -f Dockerfiles/nginx/nginx_version.txt ] && echo "::warning::Nginx 版本文件缺失，默认使用 $NGINX_VERSION"

          echo "php_version=$PHP_VERSION" >> $GITHUB_OUTPUT
          echo "nginx_version=$NGINX_VERSION" >> $GITHUB_OUTPUT
          echo "PHP_VERSION=$PHP_VERSION" >> $GITHUB_ENV
          echo "NGINX_VERSION=$NGINX_VERSION" >> $GITHUB_ENV
          echo "::endgroup::"

      - name: 构建并推送 PHP 镜像
        if: env.SKIP_BUILD_PUSH != 'true'
        run: |
          echo "::group::构建并推送 PHP 镜像"
          # 确保使用本地构建的 base 镜像而不是尝试从远程拉取
          docker buildx build --platform linux/amd64,linux/arm64 \
            --build-arg BASE_IMAGE=alpine:3.22 \
            --build-arg COMPOSER_HASH=ed0feb545ba87161262f2d45a633e34f591ebb3381f2e0063c345ebea4d228dd0043083717770234ec00c5a9f9593792 \
            -f ./Dockerfiles/php/Dockerfile \
            -t ${{ secrets.DOCKERHUB_USERNAME }}/wordpress-php:${{ steps.extract.outputs.php_version }} \
            --push . || {
              echo "::error::构建或推送 PHP 镜像失败"
              exit 1
            }
          echo "::endgroup::"
      - name: 构建并推送 Nginx 镜像
        if: env.SKIP_BUILD_PUSH != 'true'
        run: |
          echo "::group::构建并推送 Nginx 镜像"
          # 确保使用本地构建的 base 镜像而不是尝试从远程拉取
          docker buildx build --platform linux/amd64,linux/arm64 \
            --build-arg BASE_IMAGE=alpine:3.22 \
            --build-arg NGINX_VERSION=${{ steps.extract.outputs.nginx_version }} \
            -f ./Dockerfiles/nginx/Dockerfile \
            -t ${{ secrets.DOCKERHUB_USERNAME }}/wordpress-nginx:${{ steps.extract.outputs.nginx_version }} \
            --push . || {
              echo "::error::构建或推送 Nginx 镜像失败"
              exit 1
            }
          echo "::endgroup::"
      - name: 在verify-only分支上跳过构建
        if: env.SKIP_BUILD_PUSH == 'true'
        run: |
          echo "::group::跳过构建和推送步骤"
          echo "由于在verify-only分支上运行，已跳过构建和推送步骤。"
          echo "此分支专门用于验证Docker Compose配置。"
          echo "::endgroup::"



      - name: Docker Compose 验证
        run: |
          echo "::group::Docker Compose 验证"

          if [ ! -f docker-compose.yml ]; then
            echo "::error::docker-compose.yml 文件缺失"
            exit 1
          fi

          # 为验证创建测试.env文件，无论在哪个分支
          if [ ! -f .env ]; then
            echo "创建测试.env文件，因为未找到现有.env文件..."
            cat > .env << EOF
          # 用于验证的简化配置
          DOCKERHUB_USERNAME=library
          PHP_VERSION=8.3-fpm-alpine3.22
          NGINX_VERSION=1.27-alpine
          
          # 数据库配置
          MYSQL_ROOT_PASSWORD=test_root_password
          MYSQL_DATABASE=wordpress
          MYSQL_USER=wordpress
          MYSQL_PASSWORD=test_wordpress_password
          EOF
            echo "创建的.env文件内容："
            cat .env
          else
            echo "使用现有的.env文件进行验证。"
          fi

          # 统一的验证策略，无论在哪个分支都避免实际拉取自定义镜像
          echo "运行轻量级Docker Compose配置验证..."
          
          # 验证配置格式
          docker compose config -q || {
            echo "::error::docker-compose.yml 格式错误"
            exit 1
          }
          
          echo "Docker Compose配置格式正确，预览配置："
          docker compose config
          
          # 检查服务定义是否完整
          echo "验证关键服务定义..."
          MISSING_SERVICES=""
          for service in db redis wp nginx; do
            if ! docker compose config --services | grep -q "^$service$"; then
              MISSING_SERVICES="$MISSING_SERVICES $service"
            fi
          done
          
          if [ -n "$MISSING_SERVICES" ]; then
            echo "::error::缺少必要的服务定义：$MISSING_SERVICES"
            exit 1
          fi
          
          echo "所有关键服务定义完整。"
          
          # 显示详细信息帮助调试
          echo "验证完成，配置文件有效且包含所有必要服务。"
          echo "注意：在此CI环境中，我们仅验证配置格式，不实际启动容器。"
          echo "实际部署时，请确保已构建或能够拉取所需的Docker镜像。"

          echo "::endgroup::"
