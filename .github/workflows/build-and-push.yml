name: Build and Push Docker Images

on:
  push:
    branches: [ main, test-nginx-only, verify-only ]
  pull_request:
    branches: [ main, test-nginx-only, verify-only ]
  workflow_dispatch:
    # 允许手动触发工作流，不设置任何必需参数，确保所有模块都会运行一次

jobs:
  build:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: write
    # 为verify-only分支添加条件，根据分支决定是否跳过构建和推送步骤
    env:
      SKIP_BUILD_PUSH: ${{ github.ref == 'refs/heads/verify-only' }}

    steps:
      - name: 检出代码
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: 设置 Docker Buildx
        uses: docker/setup-buildx-action@v3
        with:
          install: true

      - name: 登录 Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: 检查变更的组件
        id: check-changes
        run: |
          echo "::group::检查变更组件"
          
          # 初始化变量
          CHANGED_COMPONENTS=""
          
          # 检查是否存在更新组件文件（来自版本监测脚本）
          if [ -f updated_components.txt ]; then
            echo "检测到更新组件文件"
            CHANGED_COMPONENTS=$(cat updated_components.txt)
          else
            echo "未找到更新组件文件，尝试通过git diff检测变更"
            # 尝试获取上次提交和当前提交之间的差异
            if [ ${{ github.event_name }} == 'push' ]; then
              # 对于push事件，比较当前提交和前一个提交
              git diff --name-only HEAD~1 HEAD > changed_files.txt
            else
              # 对于pull_request事件，比较PR分支和目标分支
              git fetch origin ${{ github.base_ref }}:base_branch
              git diff --name-only base_branch HEAD > changed_files.txt
            fi
            
            # 根据变更的文件判断需要更新的组件
            if grep -q "build/Dockerfiles/php/php_version.txt" changed_files.txt || \
               grep -q "build/Dockerfiles/php/composer_hash.txt" changed_files.txt || \
               grep -q "build/Dockerfiles/php/Dockerfile" changed_files.txt; then
              CHANGED_COMPONENTS="${CHANGED_COMPONENTS} php"
            fi
            
            if grep -q "build/Dockerfiles/nginx/nginx_version.txt" changed_files.txt || \
               grep -q "build/Dockerfiles/nginx/Dockerfile" changed_files.txt; then
              CHANGED_COMPONENTS="${CHANGED_COMPONENTS} nginx"
            fi
            
            if grep -q "build/Dockerfiles/base/Dockerfile" changed_files.txt; then
              CHANGED_COMPONENTS="${CHANGED_COMPONENTS} base"
            fi
          fi
          
          # 去重并格式化输出
          CHANGED_COMPONENTS=$(echo "$CHANGED_COMPONENTS" | xargs -n1 | sort -u | xargs)
          echo "变更的组件: $CHANGED_COMPONENTS"
          
          # 设置输出变量
          echo "changed_components=$CHANGED_COMPONENTS" >> $GITHUB_OUTPUT
          echo "has_changes=$([ -z "$CHANGED_COMPONENTS" ] && echo 'false' || echo 'true')" >> $GITHUB_OUTPUT
          echo "::endgroup::"

      - name: 提取 PHP 和 Nginx 版本
        id: extract
        run: |
          echo "::group::提取版本"
          PHP_VERSION=$(cat build/Dockerfiles/php/php_version.txt 2>/dev/null || echo '8.3.26')
          NGINX_VERSION=$(cat build/Dockerfiles/nginx/nginx_version.txt 2>/dev/null || echo '1.27.2')
          COMPOSER_HASH=$(cat build/Dockerfiles/php/composer_hash.txt 2>/dev/null || echo 'ed0feb545ba87161262f2d45a633e34f591ebb3381f2e0063c345ebea4d228dd0043083717770234ec00c5a9f9593792')

          [ ! -f build/Dockerfiles/php/php_version.txt ] && echo "::warning::PHP 版本文件缺失，默认使用 $PHP_VERSION"
          [ ! -f build/Dockerfiles/nginx/nginx_version.txt ] && echo "::warning::Nginx 版本文件缺失，默认使用 $NGINX_VERSION"
          [ ! -f build/Dockerfiles/php/composer_hash.txt ] && echo "::warning::Composer 哈希文件缺失，使用默认值"

          echo "php_version=$PHP_VERSION" >> $GITHUB_OUTPUT
          echo "nginx_version=$NGINX_VERSION" >> $GITHUB_OUTPUT
          echo "composer_hash=$COMPOSER_HASH" >> $GITHUB_OUTPUT
          echo "PHP_VERSION=$PHP_VERSION" >> $GITHUB_ENV
          echo "NGINX_VERSION=$NGINX_VERSION" >> $GITHUB_ENV
          echo "COMPOSER_HASH=$COMPOSER_HASH" >> $GITHUB_ENV
          echo "::endgroup::"

      - name: 构建并推送 PHP 镜像
        if: env.SKIP_BUILD_PUSH != 'true' && (contains(steps.check-changes.outputs.changed_components, 'php') || contains(steps.check-changes.outputs.changed_components, 'base'))
        run: |
          echo "::group::构建并推送 PHP 镜像"
          # 使用提取的变量构建镜像
          docker buildx build --platform linux/amd64,linux/arm64 \
            --build-arg BASE_IMAGE=alpine:3.22 \
            --build-arg COMPOSER_HASH=${{ steps.extract.outputs.composer_hash }} \
            -f ./build/Dockerfiles/php/Dockerfile \
            -t ${{ secrets.DOCKERHUB_USERNAME }}/wordpress-php:${{ steps.extract.outputs.php_version }} \
            --push . || {
              echo "::error::构建或推送 PHP 镜像失败"
              exit 1
            }
          echo "::endgroup::"
      - name: 构建并推送 Nginx 镜像
        if: env.SKIP_BUILD_PUSH != 'true' && (contains(steps.check-changes.outputs.changed_components, 'nginx') || contains(steps.check-changes.outputs.changed_components, 'base'))
        run: |
          echo "::group::构建并推送 Nginx 镜像"
          # 使用提取的变量构建镜像
          docker buildx build --platform linux/amd64,linux/arm64 \
            --build-arg BASE_IMAGE=alpine:3.22 \
            --build-arg NGINX_VERSION=${{ steps.extract.outputs.nginx_version }} \
            -f ./build/Dockerfiles/nginx/Dockerfile \
            -t ${{ secrets.DOCKERHUB_USERNAME }}/wordpress-nginx:${{ steps.extract.outputs.nginx_version }} \
            --push . || {
              echo "::error::构建或推送 Nginx 镜像失败"
              exit 1
            }
          echo "::endgroup::"
      - name: 在verify-only分支上跳过构建
        if: env.SKIP_BUILD_PUSH == 'true'
        run: |
          echo "::group::跳过构建和推送步骤"
          echo "由于在verify-only分支上运行，已跳过构建和推送步骤。"
          echo "此分支专门用于验证Docker Compose配置。"
          echo "::endgroup::"



      - name: Docker Compose 验证
        run: |
          echo "::group::Docker Compose 验证"

          if [ ! -f docker-compose.yml ]; then
            echo "::error::docker-compose.yml 文件缺失"
            exit 1
          fi

          # 为验证创建测试.env文件，无论在哪个分支
          if [ ! -f .env ]; then
            echo "创建测试.env文件，因为未找到现有.env文件..."
            cat > .env << EOF
          # 用于验证的简化配置
          DOCKERHUB_USERNAME=library
          PHP_VERSION=8.3-fpm-alpine3.22
          NGINX_VERSION=1.27-alpine
          
          # 数据库配置
          MYSQL_ROOT_PASSWORD=test_root_password
          MYSQL_DATABASE=wordpress
          MYSQL_USER=wordpress
          MYSQL_PASSWORD=test_wordpress_password
          EOF
            echo "创建的.env文件内容："
            cat .env
          else
            echo "使用现有的.env文件进行验证。"
          fi

          # 统一的验证策略，无论在哪个分支都避免实际拉取自定义镜像
          echo "运行轻量级Docker Compose配置验证..."
          
          # 验证配置格式
          docker compose config -q || {
            echo "::error::docker-compose.yml 格式错误"
            exit 1
          }
          
          echo "Docker Compose配置格式正确，预览配置："
          docker compose config
          
          # 检查服务定义是否完整
          echo "验证关键服务定义..."
          MISSING_SERVICES=""
          for service in mariadb redis php nginx; do
            if ! docker compose config --services | grep -q "^$service$"; then
              MISSING_SERVICES="$MISSING_SERVICES $service"
            fi
          done
          
          if [ -n "$MISSING_SERVICES" ]; then
            echo "::error::缺少必要的服务定义：$MISSING_SERVICES"
            exit 1
          fi
          
          echo "所有关键服务定义完整。"
          
          # 显示详细信息帮助调试
          echo "验证完成，配置文件有效且包含所有必要服务。"
          echo "注意：在此CI环境中，我们仅验证配置格式，不实际启动容器。"
          echo "实际部署时，请确保已构建或能够拉取所需的Docker镜像。"

          echo "::endgroup::"
